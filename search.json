[{"title":"Spring Boot 多数据源","url":"/2019/05/26/读书笔记/spring-boot/spring-boot-dataSource/","content":"### Spring 多数据源配置\n\n基于Druid实现多数据源的切换\n\n* application.properties配置项\n```bash\n## primary\nprimary.data.druid.url=jdbc:mysql://127.0.0.1:3306/primary?allowMultiQueries=true&autoReconnect=true&useSSL=false&useUnicode=true&characterEncoding=utf-8&nullNamePatternMatchesAll=true&serverTimezone=Asia/Shanghai\nprimary.data.druid.username=admin\nprimary.data.druid.password=123456\n## second\nsecond.data.druid.url=jdbc:mysql://127.0.0.1:3306/second?allowMultiQueries=true&autoReconnect=true&useSSL=false&useUnicode=true&characterEncoding=utf-8&nullNamePatternMatchesAll=true&serverTimezone=Asia/Shanghai\nsecond.data.druid.username=admin\nsecond.data.druid.password=123456\n```\n\n* 定义主数据源\n```bash\n@Configuration\n@ConditionalOnClass({DruidDataSource.class})\n@ConditionalOnProperty(\n        prefix = \"primary.data.druid\", //主数据源配置\n        name = {\"url\"}\n)\n@EnableConfigurationProperties\npublic class PrimaryDruidAutoConfiguration {\n    public PrimaryDruidAutoConfiguration() {\n    }\n\n    @Bean(\n            name = \"primaryDataSource\",\n            initMethod = \"init\",\n            destroyMethod = \"close\"\n    )\n    @ConfigurationProperties(\n            prefix = \"primary.data.druid\"\n    )//定义主DataSource\n    public DruidDataSource primaryDataSource() {\n        return new DruidDataSource();\n    }\n\n    @Bean\n    @ConfigurationProperties(\n            prefix = \"primary.data.druid.wall-filter\"\n    )\n    public WallConfig wallConfig(@Qualifier(\"primaryDataSource\") DruidDataSource dataSource) {\n        Iterator var2 = dataSource.getProxyFilters().iterator();\n\n        Filter filter;\n        do {\n            if (!var2.hasNext()) {\n                return new WallConfig();\n            }\n\n            filter = (Filter)var2.next();\n        } while(!(filter instanceof WallFilter));\n\n        return ((WallFilter)filter).getConfig();\n    }\n}\n\n```\n\n* 定义第二数据源\n```bash\n@Configuration\n@ConditionalOnClass({DruidDataSource.class})\n@ConditionalOnProperty(\n        prefix = \"second.data.druid\", //第二数据源配置\n        name = {\"url\"}\n)\n@EnableConfigurationProperties\npublic class SecondDruidAutoConfiguration {\n    public SecondDruidAutoConfiguration() {\n    }\n\n    @Bean(\n            name = \"secondDataSource\",\n            initMethod = \"init\",\n            destroyMethod = \"close\"\n    )\n    @ConfigurationProperties(\n            prefix = \"second.data.druid\"\n    )//定义第二DataSource\n    public DruidDataSource primaryDataSource() {\n        return new DruidDataSource();\n    }\n\n    @Bean\n    @ConfigurationProperties(\n            prefix = \"second.data.druid.wall-filter\"\n    )\n    public WallConfig wallConfig(@Qualifier(\"secondDataSource\") DruidDataSource dataSource) {\n        Iterator var2 = dataSource.getProxyFilters().iterator();\n\n        Filter filter;\n        do {\n            if (!var2.hasNext()) {\n                return new WallConfig();\n            }\n\n            filter = (Filter)var2.next();\n        } while(!(filter instanceof WallFilter));\n\n        return ((WallFilter)filter).getConfig();\n    }\n}\n\n```\n\n* 定义动态数据源\n```bash\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n    private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n\n    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources) {\n        super.setDefaultTargetDataSource(defaultTargetDataSource);\n        super.setTargetDataSources(targetDataSources);\n        super.afterPropertiesSet();\n    }\n\n    public static String getDataSource() {\n        return contextHolder.get();\n    }\n\n    public static void setDataSource(String dataSource) {\n        contextHolder.set(dataSource);\n    }\n\n    public static void clearDataSource() {\n        contextHolder.remove();\n    }\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return getDataSource();\n    }\n}\n```\n\n* 配置动态数据源\n```bash\n@Configuration\npublic class DynamicDataSourceConfiguration {\n    @Bean\n    @Primary\n    public DynamicDataSource dynamicDataSource(@Qualifier(\"primaryDataSource\") DruidDataSource primaryDataSource,\n                                               @Qualifier(\"secondDataSource\") DruidDataSource secondDataSource) {\n        Map<Object, Object> targetDataSources = new HashMap<>();\n        targetDataSources.put(\"PRIMARY\", primaryDataSource);\n        targetDataSources.put(\"SECOND\", secondDataSource);\n        return new DynamicDataSource(primaryDataSource, targetDataSources);\n    }\n}\n```\n\n* 定义切片注解\n```bash\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface SecondDataSourceAudit {\n}\n```\n\n* 实现切片方法\n```bash\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    //进入方法前，切换为第二数据源\n    @Before(\"execution( * xxx.*(..)) && @annotation(SecondDataSourceAudit)\")\n    public void switchSecondDataSource(JoinPoint point) {\n        DynamicDataSource.setDataSource(\"SECOND\");\n    }\n\n    //方法结束后，或有异常抛出后，切换为主数据源\n    @AfterReturning(\"execution( * xxx.*(..)) && @annotation(SecondDataSourceAudit)\")\n    @AfterThrowing(\"execution( * xxx.*(..)) && @annotation(SecondDataSourceAudit)\")\n    public void restoreDataSourceAfterReturning(JoinPoint point) {\n        DynamicDataSource.clearDataSource();\n    }\n}\n```\n\n* 在需要切换数据源的方法上添加注解\n```bash\n@SecondDataSourceAudit\npublic void secondDataSourceTest() {\n    //do query\n}\n```\n\n> 切换数据源需要在事务开启之前进行切换，如果事务已经开启，则数据源切换不成功\n> 即@SecondDataSourceAudit注解需要在事务控制层之前","tags":["Spring"]},{"title":"Spring Boot 异步","url":"/2019/05/25/读书笔记/spring-boot/spring-boot-async/","content":"### Spring 异步方法\n\n在Spring中通过TaskExecutor（任务执行器）实现多线程和并发编程。\n\n#### 使用并发编程的步骤如下\n\n> 使用过程中，要注意@EnableAsync注解的生效范围，如未使用@EnableAsync注解，或范围不对，则异步方法仍旧会同步执行\n\n1. 开启异步@EnableAsync\n  * 该注解用于类上，该类的所有异步方法生效\n  * 该注解用于主入口类上，或配置类上，全局异步生效\n2. 定义异步方法@Async\n  * 该注解用于类上，该类的所有方法为异步方法\n  * 该注解用于某个函数上，该函数方法为异步执行\n\n### Spring 计划任务\n\n#### 使用计划任务的步骤如下\n> 使用计划任务，同样要开启@EnableAsync注解，然后再Bean对象中编写计划任务方法\n\n1. 开启计划任务@EnableScheduling\n2. 定义计划任务@Scheduled\n#### 计划任务支持的计划方式\n* cron表达式\ncron表达式格式为 {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}\n示例\n```bash\n  @Scheduled(cron = \"0 0 12 ? * *\")//每天中午12点执行\n  public void fixTimeScheduleTask(){\n      //do something\n  }\n```\n\n* fixRate\n  按固定频率执行\n  示例\n   ```bash\n    @Scheduled(fixedRate = 5000)//每隔5秒执行一次\n    public void fixRateScheduleTask(){\n        //do something\n    }\n  ```\n  \n* fixDelay\n  按固定时间间隔执行，即距离上次执行完成之后某个固定间隔时间再次执行\n  示例\n   ```bash\n    @Scheduled(fixedDelay = 5000)//间隔5秒执行一次\n    public void fixDelayScheduleTask(){\n        //do something\n    }\n  ```","tags":["Spring"]},{"title":"Spring Boot 基础","url":"/2019/04/29/读书笔记/spring-boot/spring-boot-base/","content":"\n### Spring 核心模块\n\n*  **spring-boot**\n   Spring Boot 的主模块，也是支持其他模块的核心模块，主要包含：负责创建和刷新 Spring 容器的上下文的应用主类、内嵌式的 WEB 应用容器(Tomcat, Jetty, Undertow等)、 对配置外部化的支持、Spring 容器上下文初始化器等。\n\n* **spring-boot-autoconfigure**\n  使用 @EnableAutoConfiguration 注解启用 Spring 功能的自动配置,推断用户可能需要加载哪些 Spring Bean, 如果用户配置了其他自定义配置，那么 Spring Boot 会放弃自动配置。\n\n* **spring-boot-starters**\n  一站式的帮你打包 Spring 及相关技术应用，spring-boot-starters 这个启动器这主要提供了 spring-boot, spring-context, spring-beans 这三个 Spring 模块而已。\n\n* **spring-boot-cli**\n  这是 Spring Boot 的命令行工具，用于编译和运行 Groovy 源程序，可以十分简单的编写并运行一个应用程序。\n\n* **spring-boot-actuator**\n  这是 Spring Boot 提供的执行端点，你可以更好的监控及和你的应用程序交互。这个模块提供了像健康端点、环境端点、Spring Bean端点等。\n\n* **spring-boot-actuator-autoconfigure**\n  原理同上，为 Spring Boot 执行端点提供自动配置。\n\n* **spring-boot-test**\n  Spring Boot测试模块，为应用测试提供了许多非常有用的核心功能。\n\n* **spring-boot-test-autoconfigure**\n  原理同上，为 Spring Boot 测试模块提供自动配置。\n\n* **spring-boot-loader**\n  这个模块可以用来构建一个单独可执行的 jar 包，使用 java -jar 就能直接运行。一般不会直接使用这个来打包，使用 Spring Boot 提供的 Maven 或者 Gradle 插件就行了。\n\n* **spring-boot-devtools**\n  开发者工具模块，主要为 Spring Boot 开发阶段提供一些特性，可选，只限于本地开发阶段，当打成整包运行时这些功能会被禁用。\n\n### 依赖注入\n\n依赖注入指的是容器负责创建对象和维护对象间的依赖关系，而不需要对象本身负责自己的创建和自己的依赖；依赖注入的目的是为了解耦。Spring IoC容器(ApplicationContext)负责创建Bean，并通过容器将功能类Bean注入到需要的Bean中。\n\n**声明Bean：**\n\n* @Component 组件，没有明确角色\n  \n* @Service 用在业务层\n  \n* Responsitory 用在数据访问层(DAO层)\n  \n* @Controller 用在展现层\n  \n* @Bean\n\n**获取Bean：**\n\n* 属性：使用@Autowired、@Inject、@Resource注解，Spring项目一般用原生的@Autowired，后两个一般需要添加name注解，或变量名与Bean的name一致\n  \n* 方法参数：使用@Qualifier注解，指定Bean的name\n\n### AOP切片\n\nAOP可以让一组类或一组方法共享相同的行为。相比于OOP只能通过继承类和实现接口，来使代码的耦合度增强，类继承只能单继承，阻碍了更多行为添加到一组类上，AOP弥补了OOP的这一不足。\n\n**定义切面：**\n``` bash\n    @Aspect\n    @Component\n    public class TestAspect {\n    }\n```\n注解拦截：\n``` bash\n    @PointCut(\"@annotation(com.tong.aop.Action)\") //自定义的注解类\n    public void annotationAspect(){}\n\n    @After(\"annotationAspect\") //只要添加了@Action注解的方法都能拦截到\n    public afterAnnotationAspect(JoinPoint joinPoint){\n        //do something\n    }\n```\n方法拦截：\n``` bash\n    @PointCut(\"@execution(com.tong.service.ActionService.*(..))\") //该路径下的所有方法\n    public void methodAspect(){}\n\n    @After(\"methodAspect\")\n    public afterMethodAspectAspect(JoinPoint joinPoint){\n        //do something\n    }\n```    ","tags":["Spring"]},{"title":"First Blog","url":"/2019/04/21/hello-world/","content":"\n## Quick Start\n\n### 使用Hexo搭建博客，并创建第一个Blog\n\n### Create a new post\n\n``` bash\n$ hexo new \"blog\"\n```\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n","tags":["Hello Word"]}]